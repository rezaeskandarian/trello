import { useCallback, useMemo, useState } from "react";import {  PointerSensor,  closestCenter,  type CollisionDetection,  type DragEndEvent,  type DragStartEvent,  useSensor,  useSensors,} from "@dnd-kit/core";import type { ColumnsState, Task } from "../components/Kanban/kanban.types";import { findTaskByDraggableId } from "../utils/findTaskByDraggableIdUtils";type UseKanbanDndArgs = {  columns: ColumnsState;  onMoveTask: (event: DragEndEvent) => void;};type UseKanbanDndResult = {  sensors: ReturnType<typeof useSensors>;  collisionDetection: CollisionDetection;  activeTask: Task | null;  onDragStart: (event: DragStartEvent) => void;  onDragEnd: (event: DragEndEvent) => void;};/** * Centralizes DnD (dnd-kit) wiring for the Kanban board. * Keeps KanbanBoard component mostly presentational. * * Behavior notes: * - activeTask is derived at drag start using the same helper as before. * - onDragEnd always calls onMoveTask(event) then clears activeTask. */export const useKanbanDnd = ({  columns,  onMoveTask,}: UseKanbanDndArgs): UseKanbanDndResult => {  const [activeTask, setActiveTask] = useState<Task | null>(null);  const sensors = useSensors(    useSensor(PointerSensor, {      activationConstraint: { distance: 8 },    }),  );  const collisionDetection = useMemo(() => closestCenter, []);  const onDragStart = useCallback(    (event: DragStartEvent) => {      const task = findTaskByDraggableId(columns, event.active.id.toString());      setActiveTask(task);    },    [columns],  );  const onDragEnd = useCallback(    (event: DragEndEvent) => {      onMoveTask(event);      setActiveTask(null);    },    [onMoveTask],  );  return {    sensors,    collisionDetection,    activeTask,    onDragStart,    onDragEnd,  };};